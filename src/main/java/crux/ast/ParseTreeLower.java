package crux.ast;

import com.sun.source.tree.IdentifierTree;
import crux.ir.insts.BinaryOperator;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import crux.ast.types.*;
import crux.ast.SymbolTable.Symbol;
import org.antlr.v4.runtime.ParserRuleContext;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where decls will be by DeclVisitor Class Stmts will be resolved by StmtVisitor Class Exprs will
 * be resolved by ExprVisitor Class
 */

public final class ParseTreeLower {
  private final DeclVisitor declVisitor = new DeclVisitor();
  private final StmtVisitor stmtVisitor = new StmtVisitor();
  private final ExprVisitor exprVisitor = new ExprVisitor();

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private Type typeOf(CruxParser.TypeContext ctx) {
    String text = ctx.getText();   // Proning error
    if ("int".equals(text))
      return new IntType();
    else if ("bool".equals(text))
      return new BoolType();
    else if ("void".equals(text))
      return new VoidType();
    return new ErrorType("");
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());      // Getting error
  }

  /**
   *
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }


  /**
   * Lower top-level parse tree to AST
   *
   * @return a {@link DeclList} object representing the top-level AST.
   */

  public DeclList lower(CruxParser.ProgramContext program) {
    var pos = makePosition(program);
    symTab.enter();
    List<Declaration> declarations = new ArrayList<>();
    for (CruxParser.DeclContext declCtx : program.declList().decl()) {
      Declaration d = declCtx.accept(declVisitor);
      declarations.add(d);
    }
    symTab.exit();
    return new DeclList(pos, declarations);
  }

  /**
   * Lower stmt list by lower individual stmt into AST.
   *
   * @return a {@link StatementList} AST object.
   */
   private StatementList lower(CruxParser.StmtListContext stmtList) {
     List<Statement> stmts = new ArrayList<>();
     for (CruxParser.StmtContext stmt : stmtList.stmt()) {
       stmts.add(stmt.accept(stmtVisitor));
     }
     return new StatementList(makePosition(stmtList), stmts);
   }


  /**
   * Similar to {@link #lower(CruxParser.StmtListContext)}, but handles symbol table as well.
   *
   * @return a {@link StatementList} AST object.
   */
   private StatementList lower(CruxParser.StmtBlockContext stmtBlock) {
     symTab.enter();
     StatementList statements = lower(stmtBlock.stmtList());
     symTab.exit();
     return statements;
   }

  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree var decl and create an AST {@link VarDecl}
     *
     * @return an AST {@link VarDecl}
     */
     @Override
     public VarDecl visitVarDecl(CruxParser.VarDeclContext ctx) {
       var pos = makePosition(ctx);
       String name = ctx.Identifier().getText();
       Type type = typeOf(ctx.type());
       Symbol symbol = symTab.add(pos, name, type);
       return new VarDecl(pos, symbol);
     }


    /**
     * Visit a parse tree array decl and creates an AST {@link ArrayDecl}
     *
     * @return an AST {@link ArrayDecl}
     */
     @Override
     public Declaration visitArrayDecl(CruxParser.ArrayDeclContext ctx) {
       var pos = makePosition(ctx);
       String name = ctx.Identifier().getText();
       Type type = typeOf(ctx.type());
       int len = Integer.parseInt(ctx.Integer().getText());
       Type arraytype = new ArrayType(len, type);
       Symbol symbol = symTab.add(pos, name, arraytype);
       return new ArrayDecl(pos, symbol);
     }


    /**
     * Visit a parse tree function definition and create an AST {@link FunctionDef}
     *
     * @return an AST {@link FunctionDef}
     */
    @Override
    public Declaration visitFunctionDefn(CruxParser.FunctionDefnContext ctx) {
      var pos = makePosition(ctx);
      String functionName = ctx.Identifier().getText();

      Type returnType = (ctx.type() == null) ? new VoidType() : typeOf(ctx.type());
      List<Type> paramTypes = new ArrayList<>();
      if (ctx.paramList() != null) {
        for (CruxParser.ParamContext p : ctx.paramList().param()) {
          paramTypes.add(typeOf(p.type()));
        }
      }
      FuncType functionType = new FuncType(new TypeList(paramTypes), returnType);

      Symbol fnSymbol = symTab.add(pos, functionName, functionType);
      symTab.enter();

      List<Symbol> paramSymbols = new ArrayList<>();
      if (ctx.paramList() != null) {
        for (int i = 0; i < ctx.paramList().param().size(); i++) {
          String paramName = ctx.paramList().param(i).Identifier().getText();
          Type paramType = paramTypes.get(i);
          paramSymbols.add(symTab.add(pos, paramName, paramType));
        }
      }
      StatementList body = lower(ctx.stmtBlock());
      symTab.exit();
      return new FunctionDef(pos, fnSymbol, paramSymbols, body);
    }
  }



    /**
   * A parse tree visitor to create AST nodes derived from {@link Statement}
   */

  private final class StmtVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree var decl and create an AST {@link VarDecl}. Since {@link VarDecl} is both
     * {@link Declaration} and {@link Statement}, we simply delegate this to
     * {@link DeclVisitor#visitArrayDecl(CruxParser.ArrayDeclContext)} which we implement earlier.
     *
     * @return an AST {@link VarDecl}
     */
     @Override
     public Statement visitVarDecl(CruxParser.VarDeclContext ctx) {
       return (VarDecl) ctx.accept(declVisitor);
     }


    /**
     * Visit a parse tree assignment stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */
     @Override
     public Statement visitAssignStmt(CruxParser.AssignStmtContext ctx) {
       var pos = makePosition(ctx);
       Expression location = ctx.designator().accept(exprVisitor);
       Expression value = ctx.expr0().accept(exprVisitor);
       return new Assignment(pos, location, value);
     }


    /**
     * Visit a parse tree call stmt and create an AST {@link FunctionCall}. Since
     * {@link FunctionCall} is both {@link Expression} and {@link Statement}, we simply delegate
     * this to {@link ExprVisitor#visitCallExpr(CruxParser.CallExprContext)} that we will implement
     * later.
     *
     * @return an AST {@link FunctionCall}
     */
     @Override
     public Statement visitCallStmt(CruxParser.CallStmtContext ctx) {
         return (FunctionCall) ctx.callExpr().accept(exprVisitor);
     }


    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     *
     * @return an AST {@link IfElseBranch}
     */
     @Override
     public Statement visitIfStmt(CruxParser.IfStmtContext ctx) {
       var pos = makePosition(ctx);
       Expression condition = ctx.expr0().accept(exprVisitor);

       StatementList thenBlock = lower(ctx.stmtBlock(0));

       StatementList elseBlock = new StatementList(pos, new ArrayList<>());
       if (ctx.stmtBlock().size() > 1) {
         elseBlock = lower(ctx.stmtBlock(1));
       }

       return new IfElseBranch(pos, condition, thenBlock, elseBlock);
     }


    /**
     * Visit a parse tree for loop and create an AST {@link WhileLoop}. You'll going to use a
     * similar techniques as {@link #visitIfStmt(CruxParser.IfStmtContext)} to decompose this
     * construction.
     *
     * @return an AST {@link WhileLoop}
     */
     @Override
     public Statement visitWhileStmt(CruxParser.WhileStmtContext ctx) {
       var pos = makePosition(ctx);
       Expression condition = ctx.expr0().accept(exprVisitor);
       StatementList body = lower(ctx.stmtBlock());
       return new WhileLoop(pos, condition, body);
     }


    /**
     * Visit a parse tree return stmt and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     *
     * @return an AST {@link Return}
     */
     @Override
     public Statement visitReturnStmt(CruxParser.ReturnStmtContext ctx) {
       var pos = makePosition(ctx);
       Expression returnValue = ctx.expr0().accept(exprVisitor);
       return new Return(pos, returnValue);
     }


    /**
     * Creates a Break node
     */
     @Override
     public Statement visitBreakStmt(CruxParser.BreakStmtContext ctx) {
       var pos = makePosition(ctx);
       return new Break(pos);
     }


    /**
     * Creates a Continue node
     */
     @Override
     public Statement visitContinueStmt(CruxParser.ContinueStmtContext ctx) {
       var pos = makePosition(ctx);
       return new Continue(pos);
     }
  }

  private final class ExprVisitor extends CruxBaseVisitor<Expression> {
    /**
     * Parse Expr0 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr0(CruxParser.Expr0Context ctx) {
      if (ctx.op0() == null) {    // expr0 := expr1
        return ctx.expr1(0).accept(exprVisitor);
      } else {     // expr0 := expr1 [ op0 expr1 ]
        Expression left = ctx.expr1(0).accept(exprVisitor);
        Expression right = ctx.expr1(1).accept(exprVisitor);
        CruxParser.Op0Context operator = ctx.op0();
        OpExpr.Operation op = null;
        if (operator.Greater_Equal() != null) {
          op = OpExpr.Operation.GE;
        } else if (operator.Lesser_Equal() != null) {
          op = OpExpr.Operation.LE;
        } else if (operator.Not_Equal() != null) {
          op = OpExpr.Operation.NE;
        } else if (operator.Equal() != null) {
          op = OpExpr.Operation.EQ;
        } else if (operator.Greater_Than() != null) {
          op = OpExpr.Operation.GT;
        } else if (operator.Less_Than() != null) {
          op = OpExpr.Operation.LT;
        }
        Position pos = makePosition(ctx);
        return new OpExpr(pos, op, left, right);

      }
    }


    /**
     * Parse Expr1 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr1(CruxParser.Expr1Context ctx) {
      if (ctx.op1() == null) { // expr1 := expr2
        return ctx.expr2().accept(exprVisitor);
      }
      // expr 1 op1 expr2
      Expression left = ctx.expr1().accept(exprVisitor);
      Expression right = ctx.expr2().accept(exprVisitor);
      CruxParser.Op1Context operator = ctx.op1();
      OpExpr.Operation op = null;
      if (operator.Add() != null) {
        op = OpExpr.Operation.ADD;
      } else if (operator.Sub() != null) {
        op = OpExpr.Operation.SUB;
      } else if (operator.Or() != null) {
        op = OpExpr.Operation.LOGIC_OR;
      }
      Position pos = makePosition(ctx);
      return new OpExpr(pos, op, left, right);
    }


    /**
     * Parse Expr2 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr2(CruxParser.Expr2Context ctx) {
      if (ctx.op2() == null) { // expr3
        return ctx.expr3().accept(exprVisitor);
      }
      // expr2 op2 expr3
      Expression left = ctx.expr2().accept(exprVisitor);
      Expression right = ctx.expr3().accept(exprVisitor);

      CruxParser.Op2Context operator = ctx.op2();
      OpExpr.Operation op = null;
      if (operator.Mul() != null) {
        op = OpExpr.Operation.MULT;
      } else if (operator.Div() != null) {
        op = OpExpr.Operation.DIV;
      } else if (operator.And() != null) {
        op = OpExpr.Operation.LOGIC_AND;
      }
      Position pos = makePosition(ctx);
      return new OpExpr(pos, op, left, right);
    }
  

    /**
     * Parse Expr3 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr3(CruxParser.Expr3Context ctx) {
      if (ctx.literal() != null) { // Literal
        return visitLiteral(ctx.literal());
      } else if (ctx.designator() != null) {  // Designator
        return visitDesignator(ctx.designator());
      } else if (ctx.callExpr() != null) {  // Callexpr
        return visitCallExpr(ctx.callExpr());
      } else if (ctx.Open_Paren() != null) {  //  expr0
        return visitExpr0(ctx.expr0());
      } else {    // ! expr3
        Position pos = makePosition(ctx);
        Expression left = ctx.expr3().accept(exprVisitor);
        return new OpExpr(pos, OpExpr.Operation.LOGIC_NOT, left, null);
      }
    }


    /**
     * Create an FunctionCall Node
     */
      @Override
    public FunctionCall visitCallExpr(CruxParser.CallExprContext ctx) {
      Position pos = makePosition(ctx);
      Symbol callee = symTab.lookup(pos, ctx.Identifier().getText());
      CruxParser.ExprListContext el = ctx.exprList();
      List<Expression> ls = new ArrayList<Expression>();
      int i = 0;
      while (el.expr0(i) != null) {
        ls.add(el.expr0(i).accept(exprVisitor));
        i++;
      }
      return new FunctionCall(pos, callee, ls);
    }


    /**
     * visitDesignator will check for a name or ArrayAccess
     */
    @Override
    public Expression visitDesignator(CruxParser.DesignatorContext ctx) {
      Position pos = makePosition(ctx);
      Symbol sym = symTab.lookup(pos, ctx.Identifier().getText());
      if (ctx.Open_Bracket() != null) {  // IDENTIFIER [ "[" expr0 "]" ]
        Expression expr0 = ctx.expr0().accept(exprVisitor);
        return new ArrayAccess(pos, sym, expr0);      //TODO: Need fix
      }
      return new VarAccess(pos, sym);
    }


    /**
     * Create an Literal Node
     */
    @Override
    public Expression visitLiteral(CruxParser.LiteralContext ctx) {
      Position pos = makePosition(ctx);
      if (ctx.Integer() != null) {
        int value = Integer.parseInt(ctx.Integer().getText());
        return new LiteralInt(pos, value);
      } else if (ctx.True() != null) {
        return new LiteralBool(pos, true);
      }
      return new LiteralBool(pos, false);

    }
  }
}
